Modern software systems are increasingly built in a microservices architecture due to their scalability, resilience, and high performance. Organizations increasingly decompose monolithic systems into smaller, independently deployable services to improve agility, fault isolation, and development velocity. However, while distribution provides scalability and flexibility, it also introduces significant complexity in maintaining data consistency across multiple services. Traditional ACID (Atomicity, Consistency, Isolation, Durability) transactions in relational databases, which guarantee strong consistency in monolithic systems, are difficult or even impossible to achieve in distributed environments without compromising availability or performance. Consequently, ensuring reliable state transitions and consistent data flow across services has become one of the most challenging problems in modern system design.

Event-driven architectures (EDA) are known as a powerful paradigm for building loosely coupled distributed systems. By communicating through asynchronous events rather than direct service calls, systems can achieve higher scalability, elasticity, and fault tolerance. However, this asynchronous and decoupled nature inherently makes it difficult to coordinate distributed transactions and maintain consistency across multiple services that must cooperate to complete a business process. For example, when processing an order, the “Payment,” “Inventory,” and “Shipping” services must all reach a consistent state: either all succeed or all fail despite possibly running on different nodes or even different regions.

To address these challenges, several architectural patterns have been proposed, most notable are the Saga, Outbox, and Inbox patterns. Each pattern addresses a specific aspect of distributed data management and coordination. The **Saga pattern** provides a mechanism for managing long-lived transactions by decomposing them into a sequence of local transactions coordinated through events or commands. Each step has a corresponding compensating action, allowing the system to maintain eventual consistency without using distributed locks or two-phase commits. The Outbox pattern ensures reliable event publication by coupling database state changes with message emission in a single local transaction, preventing event loss or duplication due to failures. Finally, the Inbox pattern guarantees idempotent message consumption, ensuring that messages are processed exactly once even in the presence of retries or transient network failures. It also plays a crucial role in maintaining the correct processing order of messages, preventing out-of-order execution that could otherwise lead to inconsistent states between services.

While each of these patterns has been studied and applied individually, integrating them into a production-ready system architecture remains a complex engineering challenge. Systems must ensure that the interplay between local transactions, message brokers, and compensating actions does not introduce inconsistencies, deadlocks, or message duplication. Furthermore, real-world implementations must consider system reliability, latency, and observability, as well as developer ergonomics and operational complexity. The absence of a unified framework for combining these patterns often forces teams to develop ad hoc solutions that are difficult to maintain and verify formally.

This thesis addresses the problem of developing a fault-tolerant, event-driven system with guaranteed data consistency, built upon the Saga, Outbox, and Inbox patterns. The work explores how these patterns influence the reliability, performance, and complexity of microservice architectures. A prototype implementation demonstrates their practical application and serves as the basis for a comparative analysis with an event-driven system implemented without these patterns.
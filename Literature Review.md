The aim of my work is to develop and analyse a fault-tolerant event-driven system that guarantees data consistency and system recovery in case of failure by applying Saga, Outbox, and Inbox patterns. The study will contain a comparison between 2 systems with identical functional requirements, but one employs listed patterns and another one does not. The comparison will focus on three main aspects - reliability, performance, and architectural complexity - in order to evaluate the practical impact of applying fault-tolerance and data consistency mechanisms in microservices.

To establish a theoretical foundation for this study, it is essential to review existing literature on the architectural patterns involved. The following section provides an overview and critical analysis of studies related to the Saga, Outbox, and Inbox patterns, highlighting their principles, practical applications, implementation challenges, and comparative advantages in achieving data consistency and resilience in microservices. 

### The Saga Pattern

The Saga Pattern is one of the key mechanisms for maintaining data consistency across multiple microservices without using distributed transactions. It divides a long-lived transaction into a sequence of smaller local transactions, each executed by an individual service. If one of the steps fails, the system triggers compensating actions to undo the effects of previously completed transactions. The figure below illustrates the core idea of Saga pattern: if any of the previous steps fail, the corresponding compensating transactions are triggered.

![[saga.png]]

This concept was first introduced by Garcia-Molina and Salem in their seminal paper _“Sagas”_ [1], where they proposed sagas as a model for long-lived transactions that preserve consistency without relying on distributed two-phase commit protocols. Their work established the theoretical foundation for compensation-based recovery in distributed systems and remains a cornerstone for modern implementations of the Saga Pattern in event-driven and microservice architectures.

They discuss the conditions under which sagas provide a meaningful model: that each sub-transaction leaves the system in a consistent state (locally), that compensating transactions exist and are invoked when necessary, and that the system can tolerate partial failures by invoking those compensations rather than relying on a global rollback. Importantly, sagas avoid the need for distributed two-phase commit (2PC) with its blocking and coordination costs. Instead, they trade off strict global atomicity for eventual consistency and compensations. The article also explores recovery protocols for sagas, including how to ensure that the system recognises failed or partial commits and triggers the right compensating actions.

One of the strengths of the paper is that it provides an early, clear conceptual model for how distributed processes might coordinate via sequences of local commits and compensations. It defines key properties (e.g., isolation of sub-transactions, completion of compensations) and outlines algorithmic issues around failure detection, rollback, and commit of sagas. On the other hand, given its age, the paper remains largely conceptual and lacks empirical evaluation under contemporary microservices and event-driven systems environments. Nevertheless, this article remains highly valuable for my work, as it provides a strong theoretical foundation for understanding the core principles of the Saga Pattern and the mechanisms required to maintain data consistency in distributed systems. Its formal definitions and recovery concepts serve as a basis upon which modern implementations such as those integrating Outbox and Inbox patterns can be analyzed and extended.

Overall, this article provides a foundational contribution to understanding the theoretical principles of the Saga Pattern and the mechanisms by which distributed systems can maintain consistency through sequences of local commits and compensating transactions. While it does not offer empirical evaluations of modern frameworks, it establishes key concepts such as sub-transaction isolation, compensation logic, and failure recovery protocols. For the purposes of this work, the study serves as an essential reference for analyzing the impact of the Saga Pattern on system reliability and architectural complexity, providing a strong theoretical foundation upon which practical, event-driven implementations with Outbox and Inbox patterns can be built and evaluated.

### The Outbox Pattern

The Outbox Pattern is an essential part of reliable message delivery in event-driven architectures that rely on message brokers. The figure illustrates the Outbox Pattern in action, an application tends to write business data to a relational database and, within the same transaction, store a corresponding event. The saved event can then be processed asynchronously and published to a message broker, ensuring data consistency between the local storage and external consumers. This approach prevents data loss and reduces the risk of inconsistencies caused by partial failures in distributed nature. Both the theoretical rationale and practical implementation of this pattern are discussed in detail by Gunnar Morling in “Reliable Microservices Data Exchange With the Outbox Pattern” [2]. 
![[outbox.png]]

In his article, Morling describes how the Outbox Pattern addresses the well-known “dual writes” problem, which occurs when an application needs to update its database and send an event to another service simultaneously. The proposed solution introduces an _outbox table_ that stores pending events as part of the same database transaction as the business logic. An asynchronous worker then processes saved message and sends it to the message broker. This design guarantees atomicity between several components without relying on distributed transactions, thus improving both reliability and scalability in microservice systems.

Morling supports his explanation with a concrete implementation example using Java, PostgreSQL, Debezium, and Kafka. He demonstrates how Change Data Capture (CDC) connectors can automatically detect and publish committed changes, ensuring at-least-once delivery even under system restarts or temporary network failures. The article also discusses essential operational considerations, including message deduplication, idempotency, and topic management. However, it lacks formal performance evaluation, it provides valuable engineering insight into the trade-offs of the Outbox Pattern, such as additional infrastructure complexity and minor propagation delays. 

For my work, the article is valuable because it offers both solid theoretical foundations and practical insights, providing a real-world perspective on implementing reliable event-driven architectures. Morling illustrates how concepts like CDC and the Outbox Pattern translate into concrete engineering practices, showing how transactional outbox mechanisms can ensure fault-tolerant and consistent communication in distributed systems. Additionally, the article highlights operational challenges and mitigation strategies that are critical for evaluating the feasibility and robustness of these patterns in production environments, effectively bridging the gap between architectural theory and practical usage.

### The Inbox Pattern

While the Outbox Pattern is used to reliably send messages, the Inbox Pattern ensures idempotency and correct message ordering on the consumer side. Alaftekin’s article _“Reliable Messaging in Microservices: The Outbox and Inbox Pattern”_ [3] highlights the Inbox Pattern as a key mechanism for achieving exactly-once processing. In this pattern, each service maintains an inbox table that records incoming messages along with a unique identifier. Before processing a message, the service checks the inbox table to determine whether the message has already been handled, thereby ensuring idempotent processing and preventing duplicates. The diagram below illustrates described idea.
![[inbox.png]]

Alaftekin illustrates the Inbox Pattern in conjunction with the Outbox Pattern using a practical e-commerce example. When an order is created, the producing service saves the event in its outbox table. The consuming service then receives the event and first inserts it into its inbox table before executing any business logic. This approach guarantees that even if a message is delivered multiple times due to network retries or broker failures, it will only be processed once. The Inbox Pattern thus acts as a critical safeguard in event-driven systems, working closely with the Outbox Pattern to ensure end-to-end reliability.

The article discusses practical implementation aspects, including the need for deduplication strategies, idempotent handlers, and consistent storage for inbox records. While it does not provide formal benchmarks or large-scale performance analysis, it offers clear engineering guidance for implementing the Inbox Pattern in production systems. 

Overall, Alaftekin’s work provides valuable insights into how the Inbox Pattern ensures reliable and consistent message processing. For my thesis, this article is highly valuable because it demonstrates how consumer-side reliability mechanisms can be applied in real-world microservice architectures, offering concrete strategies to reduce the risk of inconsistent state and support robust fault-tolerant design. By focusing on these operational details, it serves as a practical reference for evaluating and designing dependable event-driven systems.

Resources:

[1] - https://dl.acm.org/doi/pdf/10.1145/38714.38742

[2] - https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/ 

[3] - https://medium.com/%40serhatalftkn/reliable-messaging-in-microservices-the-outbox-and-inbox-pattern-2f831f15ff82 

